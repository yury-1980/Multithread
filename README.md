# Multithread

В классе Main два параметра:
#### int n = 100; // Размер списка данных.
#### int threadCount = 4; // Количество потоков.

1. Создать два класса:

   a). Клиент - имеет список данных в виде List<Integer> от 1 до n. Отдельными потоками, по случайному индексу из списка
   выбирается значение (метод remove()) и в виде запроса (класс с int -полем), содержащего это значение, отправляется на
   сервер в асинхронном режиме (например отправляются со случайной задержкой между запросами - диапазон - от 100 до 500
   мс). Количество запросов равно размеру первоначального списка. Контроль: после отправки всех запросов размер списка
   данных = 0.

   b). Сервер - получает запросы от клиента. Метод обрабатывающий запрос имеет задержку в виде рандомного инта.
   Диапазон - от 100 до 1000 мс. Сервер обрабатывает запросы, используя общий для всех потоков ресурс: List<Integer>, в
   который складываются значения приходящие с запросом. В ответ от сервера передаем размер листа на момент формирования
   ответа (класс с int-полем). Итоговый контроль правильности данных на стороне сервера: список (общий ресурс) должен
   содержать значения от 1 до n без пробелов, повторений, размерность его должна составлять n
2. Клиент получает от сервера ответ и в общий для всех потоков ресурс accumulator суммирует значение из ответа от
   сервера. Итоговый контроль: accumulator = (1+n) * (n/2). Т.е. для диапазона 1-100 ответ должен быть 5050
3. Протестировать эти два класса с проверкой многопоточности
4. Протестировать взаимодействие клиента - сервера отдельным тестом (интеграционный) - обязательно
5. В реализации использовать классы пакета java.util.concurrent (обязательно Lock, Callable, Executor, Future,
   остальное - по выбору)
6. Методы класса Object (относящиеся к потокам и монитору) и ключевое слово synchronized НЕ использовать

